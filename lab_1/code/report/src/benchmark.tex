\section{Тест производительности}
Поскольку поразрядная сортировка устойчива (стабильна), то имеет смысл сравнивать её с std::stable\_sort, а не с std::sort. 

Тест производительности представляет из себя следующее: сортировка данных с помощью поразрядной сортировки сравнивается с стандартной библиотечной  std::stable\_sort. Тесты состоят из 1 тысячи, 1 миллиона и 15 миллионов строк случайно сгенерированных пар входных данных.

\begin{alltt}
art@mars:~/study/semester_3/DA/lab_1/lab1$ ls
benchmark      lab1      lab1.o    Makefile  test  TVector.cpp  TVector.o
benchmark.cpp  lab1.cpp  lab1.tar  report    tmp   TVector.h
art@mars:~/study/semester_3/DA/lab_1/lab1$ g++ -std=c++11 -g -pedantic -Wall -Werror -Wno-sign-compare -Wno-long-long -lm benchmark.cpp TVector.cpp -o benchmark
art@mars:~/study/semester_3/DA/lab_1/lab1$ ./benchmark < ../tests/1k.t 
Sorting: radix
Time of working 0.475ms.

Sorting: std::stable_sort
Time of working 0.398ms.

art@mars:~/study/semester_3/DA/lab_1/lab1$ ./benchmark < ../tests/1kk.t 
Sorting: radix
Time of working 521.863ms.

Sorting: std::stable_sort
Time of working 641.192ms.

art@mars:~/study/semester_3/DA/lab_1/lab1$ ./benchmark 
../tests/15kk.t 
Sorting: radix
Time of working 8611.44ms.

Sorting: std::stable_sort
Time of working 11757.1ms.


\end{alltt}

В reference\cite{reference} указано,что std::stable\_sort производит до $N*\log_2(N)$ сравнений элементов, если предоставлено достаточно оперативной памяти. Поразрядная сортировка выполняется за линейное время ($O(N)$). 
Теоретические расчеты расходятся с реальными данными по нескольким причинам:
\begin{enumerate}
\item В процессе сортировки создается временный массив и для каждого разряда (нескольких битов) происходит копирование из него в исходный. Поскольку нам не важны значения в вспомогательном массиве, то можно поочерёдно использовать как вспомогательный текущий и временный.
\item Реализация класса векторов для этой лабораторной далека от идеала и не выдерживает сравнения с уже реализованным в stl. Как пример можно привести использование шаблонов, оно убирает необходимость писать отдельный класс для каждого типа значений.
\end{enumerate}
\pagebreak
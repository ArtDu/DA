\section{Описание}
\qquadТребуется написать реализацию алгоритма поразрядной сортировки. Числа сортируются сортировкой подсчётом по каждому разряду. Согласно \cite{wikipedia_sort} \enqoute{Существует два варианта: least significant digit (LSD) и most significant digit (MSD). При LSD сортировке, сначала сортируются младшие разряды, затем старшие.} 
В \cite{Kormen} указано: \enquote{Сначала производиться сортировка по младшей цифре}.

\qquadДля чисел удобнее использовать разряды не в десятичном представлении, а несколько битов двоичного представления, так как для получения цифры числа в десятичном представлении используется ресурсоёмкая операция целочисленного деления на степени 10,а для двоичного лёгкие операции логического сдвига.

\qquadСогласно тому всё же\cite{Kormen} и материалам лекций для $n$ $b$-битовых чисел и цифр из $r$ битов алгоритм поразрядной сортировки выполнит сортировку за время $O(\frac{b}{r}(n+2^r))$. 
Выбирать $r$ нужно в зависимости от $\log_2{n}$. Если $b<\log_2{n}$, то $r=b$, иначе $r=\log_2{n}$.


Непосредственно про реализацию сортировки:

\qquadСперва создается временный вспомогательный массив $B$ равный исходному, затем  массив чисел $C$ размеров $2^r$ в котором будет проходить сортировка посчётом.
\qquadЧисло разбивается на непересекающиеся части по $r$ бит и сортируется посчётом по ним, начиная с младшего разряда. 

Конкретнее про сортировку подсчетом.

\qquadСовершается проход по исходному массиву, для каждой цифры значение элемента $C$ на позиции со значением этой цифры увеличивается на 1.
Затем элементы массива $C$ последовательно суммируются, таким образом в массиве $C$ значение по индексу цифры равно количеству строго меньших чем этот индекс элементов.
\qquadИдем по изначальному массиву назад(для того, чтобы сохранить устойчивость): для $j$ элемента этого массива в $C[B[j]-1]$ содержится корректный индекс этого элемента в массиве (ведь индексами ниже располагаются элементы строго меньше его).
Уменьшаем значение $C[B[j]]$ на 1 чтобы следующий элемент с таким же значением не записался поверх этого. 

\qquadКопируем в вспомогательный массив отсортированный по  текущему разряду массив и сортируем по следующему.
\pagebreak

\section{Исходный код}
На каждой непустой строке входного файла располагается пара \enquote{ключ-значение}, поэтому создадим новую структуру $TData$, в которой будем хранить ссылку на ключ, ключ в целочисленном виде и ссылку на значение.

\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {main.cpp}\\
\hline
int main()&Основная функция. В ней происходит ввод данных и управление векторами\\
\hline


\end{longtable}
Далее необходимо реализовать класс векторов. В векторе будет храниться массив структур $TData$, который будет динамически расширяться при необходимости.
\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {TVector.h, TVector.cpp}\\
\hline
TVector(long long size, long long capacity)&Конструктор. Создает пустой вектор длины аргумента функции size (с capacity равным аргументу функции capacity)\\
\hline
long long Size()&Возвращает размер вектора\\
\hline
void Print()&Выводит вектор\\
\hline
void PushBack(TData elem)&Вставляет элемент в конец вектора\\
\hline
TData \&operator[ ](size\_t ix)&Оператор, который возращает элемент под индексом ix TData из массива структур TData вектора\\
\hline
TVector \&operator\= (TVector \&vector)&Оператор присваивание одного вектора к другому.
\hline
$\sim$ TVector()&Деструктор вектора. Уничтожает массив TData\\
\hline

\end{longtable}
Листинг класса.
\begin{lstlisting}[language=C++]
struct TData{
    long keyInNum;
    char *key;
    char *val;
};

class TVector {
private:
    TData* arr;
    long long vec_size;
    long long capacity;
public:
    TVector(long long size, long long capacity);
    long long Size();
    void Print();
    void PushBack(TData elem);
    TData &operator[](size_t ix);
    TVector &operator= (TVector &vector);
    ~TVector();
};

\end{lstlisting}
Подробнее выделим функции сортировки(и их вспомогательные функции), поскольку это ключевая часть лабораторной работы
\begin{lstlisting}[language=C++]
int Log(size_t a, size_t b) {
    return (int)(log(b) / log(a));
}

int GetDigit(long n, int r, int numSys, int i) { // получить разряд по r
    return (n >> (r * i)) & (numSys - 1);
}

int GetSortPar(long n) {                         //кол-во бит каждого разряда
    if (PHONES_BITS < Log(2, n)) {
        return PHONES_BITS;
    } else {
        return (int)Log(2, n);
    }
}

void CountingSort(TVector &vec, int index, int r, int numSys) {
    long *tmp_array = new long[numSys];

    //vector of result
    TVector result(vec.Size(), vec.Size());

    for(int i=0; i<numSys; ++i) {
        tmp_array[i] = 0;
    }

    //run of data array
    for (int indexI = 0; indexI < vec.Size(); ++indexI) {
        tmp_array[GetDigit(vec[indexI].keyInNum,r,numSys,index)]++;
    }

    //adding priviously
    for(int i=1; i<=numSys; ++i) {
        tmp_array[i] += tmp_array[i-1];
    }

    for (int j = vec.Size()-1; j >= 0 ; --j) {
        TData tmp_data = vec[j];
        result[tmp_array[GetDigit(vec[j].keyInNum,r,numSys,index)]-1] = tmp_data;
        tmp_array[GetDigit(vec[j].keyInNum,r,numSys,index)]--;
    }

    vec = result;

    delete[] tmp_array;

}



void RadixSort(TVector &vec) {

    if (vec.Size() < 2) {
        return;
    }

    int r = GetSortPar(vec.Size());                 //количество бит одного разряда
    int numSys = pow(2, r);                          //система счисления
    int phoneDigits = ceil((float)PHONES_BITS / r);  //количество разрядов


    for (int index = 0; index < phoneDigits ; ++index) {
        CountingSort(vec,index, r, numSys);

    }

}

\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}art@mars:~/study/semester_3/DA/lab_1/lab1$ ls
lab1  lab1.cpp  lab1.tar  Makefile  report  test  tmp  TVector.cpp  TVector.h
art@mars:~/study/semester_3/DA/lab_1/lab1$ cat test 
+7-495-1123212	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naatt
+7-495-1123212	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naa
+375-123-1234567	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naat
+375-123-1234567	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aa\\art@mars:~/study/semester_3/DA/lab_1/lab1$ make
g++ -std=c++11 -g -pedantic -Wall -Werror -Wno-sign-compare -Wno-long-long -lm -c lab1.cpp
g++ -std=c++11 -g -pedantic -Wall -Werror -Wno-sign-compare -Wno-long-long -lm -c TVector.cpp
g++ -std=c++11 -g -pedantic -Wall -Werror -Wno-sign-compare -Wno-long-long -lm -o lab1 lab1.o TVector.o
art@mars:~/study/semester_3/DA/lab_1/lab1$ ./lab1 < test 
+7-495-1123212	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naatt
+7-495-1123212	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naa
+375-123-1234567	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3naat
+375-123-1234567	n399tann9nnt3ttnaaan9nann93na9t3a3t9999na3aan9antt3tn93aat3na
art@mars:~/study/semester_3/DA/lab_1/lab1\$ 
\end{alltt}
\pagebreak

